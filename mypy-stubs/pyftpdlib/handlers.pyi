from . import __ver__ as __ver__
from .authorizers import (
    AuthenticationFailed as AuthenticationFailed,
    AuthorizerError as AuthorizerError,
    DummyAuthorizer as DummyAuthorizer,
)
from .filesystems import (
    AbstractedFS as AbstractedFS,
    FilesystemError as FilesystemError,
)
from .ioloop import (
    Acceptor as Acceptor,
    AsyncChat as AsyncChat,
    Connector as Connector,
    RetryError as RetryError,
    timer as timer,
    _IOLoop,
)
from .log import debug as debug, logger as logger
from .servers import FTPServer

import asynchat
import io
import socket

from typing import (
    Any,
    Callable,
    IO,
    Iterable,
    Mapping,
    Optional,
    Sequence,
    Tuple,
    Type,
)

from typing_extensions import (
    Protocol,
    TypeAlias,
)

from _typeshed import ReadableBuffer

LogCallable: TypeAlias = Callable[[Any], None]

LogExceptionCallable: TypeAlias = Callable[[Any], None]

class AnyCallable(Protocol):
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

class LogFunCallable(Protocol):
    def __call__(self, *args: Any, **kwargs: Any) -> None: ...

from typing_extensions import (
    TypedDict,
)

class ProtoCmd(TypedDict):
    perm: str | None
    auth: bool
    arg: bool
    help: str

CR_BYTE: int
proto_cmds: Mapping[str, ProtoCmd]
SUPPORTS_HYBRID_IPV6: bool

class _FileReadWriteError(OSError): ...
class _GiveUpOnSendfile(Exception): ...

class PassiveDTP(Acceptor):  # type: ignore[misc]
    timeout: int
    backlog: int | None
    cmd_channel: FTPHandler
    log: LogCallable  # type: ignore[assignment]
    log_exception: LogExceptionCallable
    def __init__(self, cmd_channel: FTPHandler, extmode: bool = False) -> None: ...
    def handle_accepted(self, sock: socket.socket, addr: Tuple[str, int]) -> None: ...
    def handle_timeout(self) -> None: ...
    def handle_error(self) -> None: ...
    def close(self) -> None: ...

class ActiveDTP(Connector):  # type: ignore[misc]
    timeout: int
    cmd_channel: FTPHandler
    log: LogCallable  # type: ignore[assignment]
    log_exception: LogExceptionCallable
    def __init__(self, ip: str, port: int, cmd_channel: FTPHandler) -> None: ...
    def readable(self) -> bool: ...
    def handle_connect(self) -> None: ...
    def handle_timeout(self) -> None: ...
    def handle_close(self) -> None: ...
    def handle_error(self) -> None: ...
    def close(self) -> None: ...

class DTPHandler(AsyncChat):  # type: ignore[misc]
    timeout: int
    ac_in_buffer_size: int
    ac_out_buffer_size: int
    cmd_channel: FTPHandler
    file_obj: io.IOBase | None
    receive: bool
    transfer_finished: bool
    tot_bytes_sent: int
    tot_bytes_received: int
    cmd: str | None
    log: LogCallable  # type: ignore[assignment]
    log_exception: LogExceptionCallable
    def __init__(self, sock: socket.socket, cmd_channel: FTPHandler) -> None: ...
    def use_sendfile(self) -> bool: ...
    def push(self, data: bytes) -> None: ...
    def push_with_producer(self, producer: asynchat.simple_producer) -> None: ...
    def close_when_done(self) -> None: ...
    def initiate_send(self) -> None: ...
    def initiate_sendfile(self) -> None: ...
    def enable_receiving(self, type: str, cmd: str) -> None: ...
    def get_transmitted_bytes(self) -> int: ...
    def get_elapsed_time(self) -> float: ...
    def transfer_in_progress(self) -> bool: ...
    def send(self, data: ReadableBuffer) -> int: ...
    def refill_buffer(self) -> None: ...
    def handle_read(self) -> None: ...
    handle_read_event = handle_read
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def handle_timeout(self) -> None: ...
    def handle_error(self) -> None: ...
    def handle_close(self) -> None: ...
    def close(self) -> None: ...

class ThrottledDTPHandler(DTPHandler):  # type: ignore[misc]
    read_limit: int
    write_limit: int
    auto_sized_buffers: bool
    sleeping: bool
    ac_in_buffer_size: int
    ac_out_buffer_size: int
    def __init__(self, sock: socket.socket, cmd_channel: FTPHandler) -> None: ...
    def use_sendfile(self) -> bool: ...
    def recv(self, buffer_size: int) -> bytes: ...
    def send(self, data: ReadableBuffer) -> int: ...
    def close(self) -> None: ...

class FileProducer:
    buffer_size: int
    file: IO[bytes]
    type: str
    def __init__(self, file: IO[bytes], type: str) -> None: ...
    def more(self) -> bytes: ...

class BufferedIteratorProducer:
    loops: int
    iterator: Iterable[bytes]
    def __init__(self, iterator: Iterable[bytes]) -> None: ...
    def more(self) -> bytes: ...

class FTPHandler(AsyncChat):
    authorizer: DummyAuthorizer
    active_dtp = ActiveDTP
    passive_dtp = PassiveDTP
    dtp_handler = DTPHandler
    abstracted_fs = AbstractedFS
    proto_cmds = proto_cmds
    timeout: int
    banner: str
    max_login_attempts: int
    permit_foreign_addresses: bool
    permit_privileged_ports: bool
    masquerade_address: str | None
    masquerade_address_map: dict[str, str]
    passive_ports: Iterable[int] | None
    use_gmt_times: bool
    use_sendfile: bool
    tcp_no_delay: bool
    encoding: str
    unicode_errors: str
    log_prefix: str
    auth_failed_timeout: int
    server: FTPServer
    fs: AbstractedFS | None
    authenticated: bool
    username: str
    password: str
    attempted_logins: int
    data_channel: DTPHandler | None
    remote_ip: str
    remote_port: str
    started: float | None
    connected: bool
    def __init__(
        self, conn: socket.socket, server: FTPServer, ioloop: _IOLoop | None = None
    ) -> None: ...
    def get_repr_info(
        self, as_str: bool = False, extra_info: dict[str, Any] | None = None
    ) -> dict[str, Any]: ...
    def handle(self) -> None: ...
    def handle_max_cons(self) -> None: ...
    def handle_max_cons_per_ip(self) -> None: ...
    def handle_timeout(self) -> None: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def collect_incoming_data(self, data: bytes) -> None: ...
    def decode(self, bytes: bytes) -> str: ...
    def found_terminator(self) -> None: ...
    def pre_process_command(self, line: str, cmd: str, arg: str | None) -> None: ...
    def process_command(self, cmd: str, *args: Any, **kwargs: Any) -> None: ...
    def handle_error(self) -> None: ...
    def handle_close(self) -> None: ...
    def close(self) -> None: ...
    def on_connect(self) -> None: ...
    def on_disconnect(self) -> None: ...
    def on_login(self, username: str) -> None: ...
    def on_login_failed(self, username: str, password: str) -> None: ...
    def on_logout(self, username: str) -> None: ...
    def on_file_sent(self, file: str) -> None: ...
    def on_file_received(self, file: str) -> None: ...
    def on_incomplete_file_sent(self, file: str) -> None: ...
    def on_incomplete_file_received(self, file: str) -> None: ...
    def push(self, data: bytes) -> None: ...
    def respond(self, resp: str, logfun: LogFunCallable = ...) -> None: ...
    def respond_w_warning(self, resp: str) -> None: ...
    def push_dtp_data(
        self,
        data: str,
        isproducer: bool = False,
        file: IO[bytes] | None = None,
        cmd: str | None = None,
    ) -> None: ...
    def flush_account(self) -> None: ...
    def run_as_current_user(
        self, function: AnyCallable, *args: Any, **kwargs: Any
    ) -> Any: ...
    def log(self, msg: str, logfun: LogFunCallable = ...) -> None: ...
    def logline(self, msg: str, logfun: LogFunCallable = ...) -> None: ...
    def logerror(self, msg: str) -> None: ...
    def log_exception(self, instance: Any) -> None: ...
    log_cmds_list: Sequence[str]
    def log_cmd(self, cmd: str, arg: str, respcode: int, respstr: str) -> None: ...
    def log_transfer(
        self,
        cmd: str,
        filename: str,
        receive: bool,
        completed: bool,
        elapsed: float,
        bytes: int,
    ) -> None: ...
    def ftp_PORT(self, line: str) -> None: ...
    def ftp_EPRT(self, line: str) -> None: ...
    def ftp_PASV(self, line: str) -> None: ...
    def ftp_EPSV(self, line: str) -> None: ...
    def ftp_QUIT(self, line: str) -> None: ...
    def ftp_LIST(self, path: str) -> str | None: ...
    def ftp_NLST(self, path: str) -> str | None: ...
    def ftp_MLST(self, path: str) -> str | None: ...
    def ftp_MLSD(self, path: str) -> str | None: ...
    def ftp_RETR(self, file: str) -> str | None: ...
    def ftp_STOR(self, file: str, mode: str = "w") -> str | None: ...
    def ftp_STOU(self, line: str) -> str | None: ...
    def ftp_APPE(self, file: str) -> str | None: ...
    def ftp_REST(self, line: str) -> None: ...
    def ftp_ABOR(self, line: str) -> None: ...
    def ftp_USER(self, line: str) -> None: ...
    def handle_auth_failed(self, msg: str, password: str) -> None: ...
    def handle_auth_success(self, home: str, password: str, msg_login: str) -> None: ...
    def ftp_PASS(self, line: str) -> None: ...
    def ftp_REIN(self, line: str) -> None: ...
    def ftp_PWD(self, line: str) -> None: ...
    def ftp_CWD(self, path: str) -> str | None: ...
    def ftp_CDUP(self, path: str) -> str | None: ...
    def ftp_SIZE(self, path: str) -> None: ...
    def ftp_MDTM(self, path: str) -> str | None: ...
    def ftp_MFMT(self, path: str, timeval: str) -> Tuple[str, str] | None: ...
    def ftp_MKD(self, path: str) -> str | None: ...
    def ftp_RMD(self, path: str) -> None: ...
    def ftp_DELE(self, path: str) -> str | None: ...
    def ftp_RNFR(self, path: str) -> None: ...
    def ftp_RNTO(self, path: str) -> Tuple[str, str] | None: ...
    def ftp_TYPE(self, line: str) -> None: ...
    def ftp_STRU(self, line: str) -> None: ...
    def ftp_MODE(self, line: str) -> None: ...
    def ftp_STAT(self, path: str) -> str | None: ...
    def ftp_FEAT(self, line: str) -> None: ...
    def ftp_OPTS(self, line: str) -> None: ...
    def ftp_NOOP(self, line: str) -> None: ...
    def ftp_SYST(self, line: str) -> None: ...
    def ftp_ALLO(self, line: str) -> None: ...
    def ftp_HELP(self, line: str) -> None: ...
    def ftp_SITE_CHMOD(self, path: str, mode: str) -> Tuple[str, str] | None: ...
    def ftp_SITE_HELP(self, line: str) -> None: ...
    def ftp_XCUP(self, line: str) -> str | None: ...
    def ftp_XCWD(self, line: str) -> str | None: ...
    def ftp_XMKD(self, line: str) -> str | None: ...
    def ftp_XPWD(self, line: str) -> None: ...
    def ftp_XRMD(self, line: str) -> None: ...

import OpenSSL.SSL

Context: TypeAlias = OpenSSL.SSL.Context

class SSLConnection:
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    socket: socket.socket | None
    def secure_connection(self, ssl_context: Context) -> None: ...
    def handle_ssl_established(self) -> None: ...
    def handle_ssl_shutdown(self) -> None: ...
    def handle_failed_ssl_handshake(self) -> None: ...
    def handle_read_event(self) -> None: ...
    def handle_write_event(self) -> None: ...
    def handle_error(self) -> None: ...
    def send(self, data: ReadableBuffer) -> int: ...
    def recv(self, buffer_size: int) -> bytes: ...
    def close(self) -> None: ...

class TLS_DTPHandler(SSLConnection, DTPHandler):  # type: ignore[misc]
    def __init__(self, sock: socket.socket, cmd_channel: FTPHandler) -> None: ...
    def use_sendfile(self) -> bool: ...
    def handle_failed_ssl_handshake(self) -> None: ...

class TLS_FTPHandler(SSLConnection, FTPHandler):
    tls_control_required: bool
    tls_data_required: bool
    certfile: str | None
    keyfile: str | None
    ssl_protocol: str
    ssl_options: int
    ssl_context: Context
    dtp_handler = TLS_DTPHandler
    proto_cmds: Mapping[str, ProtoCmd]
    def __init__(
        self, conn: socket.socket, server: FTPServer, ioloop: _IOLoop | None = None
    ) -> None: ...
    @classmethod
    def get_ssl_context(cls) -> Context: ...
    def flush_account(self) -> None: ...
    def process_command(self, cmd: str, *args: Any, **kwargs: Any) -> None: ...
    def close(self) -> None: ...
    def handle_failed_ssl_handshake(self) -> None: ...
    def ftp_AUTH(self, line: str) -> None: ...
    def ftp_PBSZ(self, line: str) -> None: ...
    def ftp_PROT(self, line: str) -> None: ...
